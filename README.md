# computer-networking
计算机网络自顶向下习题及实验记录



## 第二章

在做第二章的第一个作业 http web 服务器中直观的体会到了HTTP请求的本质就是建立在运输层之上的一系列报文，HTTP服务器的核心是按照HTTP协议规定的内容解析请求报文，并作出相应的动作

1. 通过URL获取服务器上的指定文件，文件存在则返回200，不存在返回404
2. 通过解析 `if-modified-since` 实现了条件GET请求
3. 返回文件字节内容时采用分块获取发送TCP请求

同时也初步熟悉了 Python 语言的用法

1. 字符串处理，比如切分，格式化拼接
2. 时间使用了 datetime 模块
3. 从数组构建字典，表达式还是不大熟练
4. 方法的默认参数在定义的时候就已确定（原本还想用now()）
5. 内置的 `textwrap`,`sys`,`time`模块使用



工作中遇到过下载大点的附件中途会失败的问题，使用 postman 调试发现响应结果总是先显示 HTTP 200 成功，然后一直 loading 下载内容。一直觉得有点疑问，虽然知道应该是受限于最大报文段长度（MSS），因此分了多次 TCP 请求返回，HTTP 响应头在先到的 TCP 请求中，所以才会先显示 HTTP 200，但总感觉没有想得很明白。

通过作业自己写 HTTP 服务器，为了~~（偷懒不想生成大文件）~~模拟稍微大点的文件，我在返回 response body 时每次只读取 1 字节的数据写入 socket，并且写入之后使用 `time.sleep(0.5)` 等待了 0.5 秒，从 postman 上看的现象就是先显示 HTTP 200 成功，然后一直 loading 下载内容。

通过 wireshark 抓包也能看出，每次 TCP 请求的报文也只有1字节（暂时还不会看是否合并了多个TCP请求一块发送，不过影响不大）。

![image-20241222183548197](https://cdn.jsdelivr.net/gh/hyb0302/markdown-pic@main//img/image-20241222183548197.png)



通过这次的作业站在服务器的视角，我能够比较直观的了解这个现象背后的本质：**从运输层角度看，HTTP 请求只是一串 TCP 报文，只不过内容是规范的协议文本。**

